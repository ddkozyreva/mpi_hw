# Задание №3 - распределенные вычисления с MPI

## Задание

(eigenvector.cpp) Функция eigenvalue вычисляет максимальное по модулю собственное значение матрицы. Для этого используется алгоритм простой итерации: генерируется случайный вектор x, а затем повторяются вычисления

- $ y←Ax $

- $ y ← y / ||y|| $ (нормализация) 

- $ x←y $

После большого числа итераций в x остается только компонента вдоль собственного
вектора матрицы A с максимальным по модулю собственным числом.
Программа запрашивает целое число N, генерирует случайную симметричную матрицу и проводит итерации указанного алгоритма до тех пор, пока Ax не будет слабо отличаться от $x⋅(x^T⋅A⋅x) / (x^T⋅x) $, после чего выводит отношение Рэлея $R = (x^T⋅A⋅x) / (x^T⋅x)$ как приближение к собственному числу.
В приведенной реализации матрица $A$ хранится на процессах распределенно, а векторы $x$ и $e$ хранятся полностью. На каждой итерации процесс вычисляет часть произведения $y = Ax$, а затем полный вектор собирается через MPI_Allgather.
1. Переписать функцию scatter_matrix, чтобы она работала без предположения делимости N на число процессов нацело (использовать MPI_Scatterv / MPI_Gatherv для распределения данных по процессам) (3б.)
2. Рассмотреть вариант решения, в котором вектор y также хранится распределённо на процессах. В этом случае нужно распараллелить вычисление скалярного произведения $(x^T y)$ и максимального отличия $y_i - R x_i$. Сравнить производительность и эффективность параллелизации двух версий программы. (3б.)
3. Получить зависимость эффективности параллелизации от числа процессов в случае, когда все процессы на одном вычислительном узле и на различных вычислительных узлах. (2б.)

## Решение